import 'dart:async';
import 'dart:math' as math;
import 'dart:typed_data';
import 'dart:ui' as ui;
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:wiselover/src/rust/api/live2d_model_api.dart';
import 'package:wiselover/src/live2d/live2d_model_manager.dart';

/// Live2D æ¨¡å‹æŸ¥çœ‹å™¨ Widget
class Live2DViewer extends StatefulWidget {
  final bool wireframe;
  const Live2DViewer({super.key, this.wireframe = false});

  @override
  State<Live2DViewer> createState() => _Live2DViewerState();
}

class _Live2DViewerState extends State<Live2DViewer> {
  bool _isLoading = true;
  String? _error;
  Timer? _updateTimer;

  @override
  void initState() {
    super.initState();
    // ç›‘å¬æ¨¡å‹ç®¡ç†å™¨æ›´æ–°
    Live2DModelManager.instance.addListener(_onModelUpdate);
    _loadModel();
  }

  @override
  void dispose() {
    _updateTimer?.cancel();
    Live2DModelManager.instance.removeListener(_onModelUpdate);
    super.dispose();
  }

  void _onModelUpdate() {
    if (mounted) {
      // å½“æ¨¡å‹æ›´æ–°æ—¶è§¦å‘é‡ç»˜
      setState(() {});
    }
  }

  Future<void> _loadModel() async {
    try {
      await Live2DModelManager.instance.loadModel();

      if (!Live2DModelManager.instance.isLoaded) {
        throw Exception('Model loaded but isLoaded returns false');
      }

      // å¯åŠ¨å®šæ—¶å™¨æ›´æ–°å¸§ï¼ˆ60 FPSï¼‰å¹¶æ·»åŠ ç®€å•åŠ¨ç”»
      var animationTime = 0.0;
      _updateTimer = Timer.periodic(const Duration(milliseconds: 16), (timer) {
        if (mounted && Live2DModelManager.instance.isLoaded) {
          // æ·»åŠ ç®€å•çš„å‘¼å¸åŠ¨ç”»
          animationTime += 0.016; // çº¦ 60 FPS
          final breath =
              (math.sin(animationTime * 2.0) * 0.5 + 0.5) * 0.3; // 0 åˆ° 0.3

          // è®¾ç½®å‘¼å¸å‚æ•°ï¼ˆå¦‚æœæ¨¡å‹æœ‰è¿™ä¸ªå‚æ•°ï¼‰
          try {
            Live2DModelManager.instance.setParameter('PARAM_BREATH', breath);
          } catch (e) {
            // å‚æ•°å¯èƒ½ä¸å­˜åœ¨ï¼Œå¿½ç•¥é”™è¯¯
          }

          // æ›´æ–°æ¨¡å‹å¹¶è§¦å‘é‡ç»˜
          Live2DModelManager.instance.update();
          if (mounted) {
            setState(() {}); // è§¦å‘é‡ç»˜
          }
        } else {
          timer.cancel();
        }
      });

      setState(() {
        _isLoading = false;
      });

      if (kDebugMode) {
        debugPrint('âœ“ Live2DViewer: Model loaded and viewer initialized');
        final frame = Live2DModelManager.instance.currentFrame;
        if (frame != null) {
          debugPrint('  Current frame: ${frame.drawables.length} drawables');
        }
      }
    } catch (e, stackTrace) {
      debugPrint('âŒ Error loading model in Live2DViewer: $e');
      debugPrint('Stack trace: $stackTrace');
      setState(() {
        _error = e.toString();
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    if (_error != null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error, color: Colors.red, size: 48),
            const SizedBox(height: 16),
            Text('åŠ è½½æ¨¡å‹å¤±è´¥: $_error'),
            const SizedBox(height: 16),
            ElevatedButton(onPressed: _loadModel, child: const Text('é‡è¯•')),
          ],
        ),
      );
    }

    if (!Live2DModelManager.instance.isLoaded) {
      return const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            CircularProgressIndicator(),
            SizedBox(height: 16),
            Text('æ¨¡å‹åŠ è½½ä¸­...'),
          ],
        ),
      );
    }

    final currentFrame = Live2DModelManager.instance.currentFrame;
    final textures = Live2DModelManager.instance.textures;

    if (kDebugMode && currentFrame == null) {
      debugPrint('âš  Live2DViewer: Model is loaded but currentFrame is null');
    }

    return RepaintBoundary(
      child: SizedBox.expand(
        child: CustomPaint(
          painter: _Live2DPainter(
            textures: textures,
            frame: currentFrame,
            wireframe: widget.wireframe,
          ),
        ),
      ),
    );
  }
}

class _Live2DPainter extends CustomPainter {
  final List<ui.Image> textures;
  final FrameDto? frame;
  final bool wireframe;

  _Live2DPainter({
    required this.textures,
    required this.frame,
    this.wireframe = false,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final f = frame;
    if (f == null || f.drawables.isEmpty || textures.isEmpty) {
      final paint = Paint()..color = const Color(0xFFF5F5F5);
      canvas.drawRect(Offset.zero & size, paint);
      return;
    }

    // ç»˜åˆ¶èƒŒæ™¯
    final bgPaint = Paint()..color = const Color(0xFFF5F5F5);
    canvas.drawRect(Offset.zero & size, bgPaint);

    // Live2D åæ ‡ç³»ï¼šåŸç‚¹åœ¨ä¸­å¿ƒï¼ŒYè½´å‘ä¸Š
    // Flutter åæ ‡ç³»ï¼šåŸç‚¹åœ¨å·¦ä¸Šè§’ï¼ŒYè½´å‘ä¸‹
    final cw = f.canvasWidth > 0 ? f.canvasWidth : 2.0;
    final ch = f.canvasHeight > 0 ? f.canvasHeight : 2.0;

    // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ - ä½¿ç”¨canvaså°ºå¯¸
    final sx = size.width / cw;
    final sy = size.height / ch;
    final scale = (sx < sy ? sx : sy) * 0.8; // ç•™å‡ºè¾¹è·

    // åæ ‡è½¬æ¢ï¼šLive2Dæ ‡å‡†ä¸­å¿ƒåæ ‡ç³»
    canvas.save();
    final centerX = size.width / 2;
    final centerY = size.height / 2;
    
    // ç§»åŠ¨åˆ°å±å¹•ä¸­å¿ƒï¼Œç¼©æ”¾ï¼Œç¿»è½¬Yè½´
    canvas.translate(centerX, centerY);
    canvas.scale(scale, -scale);

    // æŒ‰ drawOrder æ’åº
    final sorted = List<DrawableFrameDto>.from(f.drawables)
      ..sort((a, b) => a.drawOrder.compareTo(b.drawOrder));

    int drawnCount = 0;

    // ç»˜åˆ¶æ‰€æœ‰ drawable
    for (final d in sorted) {
      // åŸºæœ¬éªŒè¯ - è·³è¿‡ä¸å¯è§æˆ–æ— æ•ˆçš„drawable
      if (d.opacity <= 0.001) continue; // è·³è¿‡é€æ˜çš„
      if (d.vertices.length < 4) continue; // è‡³å°‘éœ€è¦2ä¸ªé¡¶ç‚¹ï¼ˆ4ä¸ªfloatï¼‰
      if (d.indices.length < 3) continue; // è‡³å°‘éœ€è¦1ä¸ªä¸‰è§’å½¢
      if (d.textureIndex < 0 || d.textureIndex >= textures.length) continue;

      final image = textures[d.textureIndex];
      if (image.width == 0 || image.height == 0) continue;

      // å‡†å¤‡é¡¶ç‚¹åæ ‡
      final positions = <ui.Offset>[];
      for (var i = 0; i + 1 < d.vertices.length; i += 2) {
        positions.add(Offset(d.vertices[i], d.vertices[i + 1]));
      }

      if (positions.isEmpty) continue;

      // å‡†å¤‡çº¹ç†åæ ‡ï¼ˆå½’ä¸€åŒ–åæ ‡ 0-1ï¼‰
      final texCoords = <ui.Offset>[];
      for (var i = 0; i < d.uvs.length - 1; i += 2) {
        texCoords.add(Offset(
          d.uvs[i].clamp(0.0, 1.0),
          d.uvs[i + 1].clamp(0.0, 1.0),
        ));
      }

      // å¦‚æœUVæ•°é‡ä¸è¶³ï¼Œå¡«å……é»˜è®¤å€¼
      while (texCoords.length < positions.length) {
        texCoords.add(texCoords.isNotEmpty ? texCoords.first : Offset.zero);
      }

      // éªŒè¯å¹¶è¿‡æ»¤ç´¢å¼•
      final validIndices = <int>[];
      for (var idx in d.indices) {
        if (idx >= 0 && idx < positions.length) {
          validIndices.add(idx);
        }
      }

      // ç¡®ä¿ç´¢å¼•æ•°é‡æ˜¯3çš„å€æ•°
      final triangleCount = validIndices.length ~/ 3;
      if (triangleCount == 0) continue;
      
      final indexList = Uint16List.fromList(validIndices.sublist(0, triangleCount * 3));

      // åˆ›å»ºé¡¶ç‚¹æ•°æ®
      final positionList = Float32List.fromList(
        positions.expand((e) => [e.dx, e.dy]).toList(),
      );
      final texCoordList = Float32List.fromList(
        texCoords.expand((e) => [e.dx, e.dy]).toList(),
      );
      final indexList = Uint16List.fromList(validIndices);

      // åˆ›å»º ImageShader
      ui.ImageShader? shader;
      try {
        shader = ui.ImageShader(
          image,
          TileMode.clamp,
          TileMode.clamp,
          Float64List.fromList([
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
          ]),
        );
      } catch (e, stackTrace) {
        skippedTexture++;
        if (kDebugMode && skippedTexture <= 5) {
          debugPrint('âŒ Failed to create ImageShader: $e');
          debugPrint('  Texture: ${image.width}x${image.height}');
          debugPrint('  Stack trace: $stackTrace');
        }
        continue;
      }

      // åˆ›å»ºé¡¶ç‚¹å¯¹è±¡
      final vertices = ui.Vertices.raw(
        ui.VertexMode.triangles,
        positionList,
        textureCoordinates: texCoordList,
        indices: indexList,
      );

      // å¤„ç† multiply color
      final multiply = d.multiplyColor;
      ColorFilter? colorFilter;
      if (multiply.length >= 4) {
        final r = multiply[0].clamp(0.0, 1.0);
        final g = multiply[1].clamp(0.0, 1.0);
        final b = multiply[2].clamp(0.0, 1.0);
        final a = multiply[3].clamp(0.0, 1.0);

        if ((r - 1.0).abs() > 0.001 ||
            (g - 1.0).abs() > 0.001 ||
            (b - 1.0).abs() > 0.001 ||
            (a - 1.0).abs() > 0.001) {
          colorFilter = ColorFilter.matrix([
            r,
            0,
            0,
            0,
            0,
            0,
            g,
            0,
            0,
            0,
            0,
            0,
            b,
            0,
            0,
            0,
            0,
            0,
            a,
            0,
          ]);
        }
      }

      // åˆ›å»º Paint
      // ç¡®ä¿opacityè‡³å°‘ä¸º0.01ï¼Œè¿™æ ·å³ä½¿å¾ˆå°çš„opacityä¹Ÿèƒ½çœ‹åˆ°
      final opacity = d.opacity.clamp(0.01, 1.0);
      final alphaValue = (opacity * 255).round().clamp(1, 255);

      final paint = Paint()
        ..filterQuality = FilterQuality.high
        ..shader = shader
        ..color = Color.fromARGB(alphaValue, 255, 255, 255)
        ..blendMode = BlendMode.srcOver
        ..isAntiAlias = true;

      if (colorFilter != null) {
        paint.colorFilter = colorFilter;
      }

      // ç»˜åˆ¶
      try {
        // ç¡®ä¿shaderä¸ä¸ºnull
        if (paint.shader == null) {
          if (kDebugMode && drawnCount < 10) {
            debugPrint(
              'âš  Skipped drawable $processedCount: paint.shader is null',
            );
          }
          continue;
        }

        // ç»˜åˆ¶é¡¶ç‚¹
        canvas.drawVertices(vertices, BlendMode.srcOver, paint);
        drawnCount++;

        if (kDebugMode) {
          if (drawnCount <= 10) {
            debugPrint(
              'âœ“ Drawn drawable $drawnCount: ${positions.length} vertices, '
              '${validIndices.length ~/ 3} triangles, opacity=${opacity.toStringAsFixed(3)}, '
              'texture=${image.width}x${image.height}',
            );
            // è¾“å‡ºç¬¬ä¸€ä¸ªé¡¶ç‚¹çš„åæ ‡ç”¨äºè°ƒè¯•
            if (positions.isNotEmpty) {
              debugPrint(
                '  First vertex (original): (${d.vertices[0].toStringAsFixed(2)}, ${d.vertices[1].toStringAsFixed(2)})',
              );
              debugPrint(
                '  First vertex (transformed): (${positions[0].dx.toStringAsFixed(2)}, ${positions[0].dy.toStringAsFixed(2)})',
              );
            }
          }
          // æ¯ç»˜åˆ¶10ä¸ªdrawableè¾“å‡ºä¸€æ¬¡è¿›åº¦
          if (drawnCount % 10 == 0) {
            debugPrint(
              '  Progress: $drawnCount/${sorted.length} drawables drawn',
            );
          }
        }
      } catch (e, stackTrace) {
        if (kDebugMode && drawnCount < 10) {
          debugPrint('âŒ Error drawing drawable $drawnCount: $e');
          debugPrint('  Stack trace: $stackTrace');
          debugPrint(
            '  Details: vertices=${positions.length}, indices=${validIndices.length}, '
            'texture=${image.width}x${image.height}, shader=${paint.shader != null}',
          );
        }
      }
    }

    canvas.restore();

    if (kDebugMode) {
      debugPrint(
        'ğŸ“Š Render summary: ${drawnCount}/${f.drawables.length} drawables drawn',
      );
      debugPrint(
        '   Skipped: opacity=$skippedOpacity, vertices=$skippedVertices, '
        'indices=$skippedIndices, texture=$skippedTexture, invalidIndices=$skippedInvalidIndices',
      );
      if (drawnCount == 0) {
        debugPrint('âŒ No drawables were drawn!');
        debugPrint(
          '   This means all drawables were skipped. Check the skip reasons above.',
        );
      } else {
        debugPrint('âœ“ Successfully drew $drawnCount drawables');
      }
    }
  }

  @override
  bool shouldRepaint(covariant _Live2DPainter oldDelegate) {
    if (oldDelegate.frame != frame) return true;
    if (oldDelegate.textures.length != textures.length) return true;
    for (int i = 0; i < textures.length; i++) {
      if (i >= oldDelegate.textures.length ||
          textures[i] != oldDelegate.textures[i]) {
        return true;
      }
    }
    return false;
  }
}
